"""
Windows server scanner using WinRM for remote management.
Implements Windows-specific security checks for the security audit system.
"""

import winrm
import json
import logging
from typing import List, Dict, Any, Optional

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("windows_scanner.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("windows-scanner")

class WindowsScanner:
    """Scanner for Windows servers using WinRM"""
    
    def __init__(self, server_ip: str, username: str, password: str):
        """Initialize the Windows scanner"""
        self.server_ip = server_ip
        self.username = username
        self.password = password
        self.session = None
    
    def connect(self) -> bool:
        """Connect to the Windows server using WinRM"""
        try:
            logger.info(f"Connecting to Windows server {self.server_ip} with WinRM")
            # Create a WinRM session
            self.session = winrm.Session(
                self.server_ip, 
                auth=(self.username, self.password),
                transport='ntlm',  # Using NTLM authentication
                server_cert_validation='ignore'  # For testing; in production, use proper cert validation
            )
            
            # Test connection
            result = self.session.run_ps("Write-Output 'Connection test successful'")
            if result.status_code == 0:
                logger.info(f"Successfully connected to {self.server_ip}")
                return True
            else:
                logger.error(f"Connection test failed: {result.std_err}")
                return False
                
        except Exception as e:
            logger.error(f"Error connecting to Windows server: {str(e)}")
            return False
    
def run_powershell_command(self, command: str) -> Dict[str, Any]:
    """Run a PowerShell command on the Windows server"""
    if not self.session:
        logger.error("No active WinRM session")
        return {
            "status": "Error",
            "output": "No active WinRM session",
            "error": "Session not established"
        }
    
    try:
        logger.info(f"Running PowerShell command: {command}")
        
        # Оборачиваем команду в скрипт, который отключает вывод прогресса и очищает результат
        wrapped_command = """
        $ProgressPreference = 'SilentlyContinue'
        $ErrorActionPreference = 'Continue'
        
        try {
            # Выполняем оригинальную команду
            %s
        }
        catch {
            Write-Output "Command error: $_"
        }
        """ % command
        
        # Execute the command
        result = self.session.run_ps(wrapped_command)
        
        # Process the result
        if result.status_code == 0:
            logger.info("Command executed successfully")
            # Очистка вывода от CLIXML
            output = result.std_out.decode('utf-8', errors='replace').strip()
            output = output.replace("#< CLIXML", "").replace("<Objs Version", "").replace("</Objs>", "")
            if "Preparing modules for first use" in output:
                output = "Command executed successfully"
                
            return {
                "status": "Success",
                "output": output,
                "error": result.std_err.decode('utf-8', errors='replace').strip()
            }
        else:
            logger.warning(f"Command execution failed with status code {result.status_code}")
            return {
                "status": "Failed",
                "output": result.std_out.decode('utf-8', errors='replace').strip(),
                "error": result.std_err.decode('utf-8', errors='replace').strip()
            }
            
    except Exception as e:
        logger.error(f"Error executing PowerShell command: {str(e)}")
        return {
            "status": "Error",
            "output": "",
            "error": str(e)
        }
    
    def determine_status(self, criterion_id: int, output: str, expected: str) -> str:
        """Determine if a check passes or fails based on the output and expected value"""
        logger.info(f"Determining status for criterion {criterion_id}: Output='{output}', Expected='{expected}'")
        
        # Windows-specific handling for certain registry checks
        if expected == "True" and output.lower() == "true":
            logger.info(f"Criterion {criterion_id} PASSED (Boolean true check)")
            return "Pass"
            
        # For numeric registry values
        if expected.isdigit() and output.strip() == expected:
            logger.info(f"Criterion {criterion_id} PASSED (Numeric value match)")
            return "Pass"
            
        # For string values with exact match
        if output.strip() == expected:
            logger.info(f"Criterion {criterion_id} PASSED (Exact string match)")
            return "Pass"
            
        # For case-insensitive string values (common for registry)
        if output.lower().strip() == expected.lower():
            logger.info(f"Criterion {criterion_id} PASSED (Case-insensitive match)")
            return "Pass"
            
        # For checks where expected value is contained in output
        if expected in output:
            logger.info(f"Criterion {criterion_id} PASSED (Substring match)")
            return "Pass"
            
        # For checks with special keywords
        if "disabled" in expected.lower() and "disabled" in output.lower():
            logger.info(f"Criterion {criterion_id} PASSED (Disabled status match)")
            return "Pass"
            
        if "enabled" in expected.lower() and "enabled" in output.lower():
            logger.info(f"Criterion {criterion_id} PASSED (Enabled status match)")
            return "Pass"
            
        # For "not installed" or similar negative checks
        if "not" in expected.lower() and expected.lower() in output.lower():
            logger.info(f"Criterion {criterion_id} PASSED (Negative state match)")
            return "Pass"
            
        # Default case - if no conditions are met, it's a fail
        logger.info(f"Criterion {criterion_id} FAILED - Output doesn't match expected value")
        return "Fail"
    
    def perform_scan(self, criteria: List[Any]) -> List[Dict[str, Any]]:
        """
        Scan the Windows server against the provided criteria
        
        Args:
            criteria: List of criteria objects to check
            
        Returns:
            List of scan results
        """
        results = []
        
        if not self.connect():
            logger.error("Failed to connect to the Windows server")
            for criterion in criteria:
                results.append({
                    "criterion_id": criterion.id,
                    "status": "Error",
                    "details": "Failed to connect to the Windows server",
                    "remediation": criterion.remediation
                })
            return results
        
        # For each criterion, run the check and evaluate the result
        for criterion in criteria:
            try:
                logger.info(f"Checking criterion {criterion.id}: {criterion.name}")
                
                # Skip criteria without a check command
                if not criterion.check_command:
                    logger.warning(f"No check command for criterion {criterion.id}, skipping")
                    results.append({
                        "criterion_id": criterion.id,
                        "status": "Error",
                        "details": "No check command defined",
                        "remediation": criterion.remediation
                    })
                    continue
                
                # Run the PowerShell command
                command_result = self.run_powershell_command(criterion.check_command)
                
                # If the command failed, mark as error
                if command_result["status"] == "Error":
                    logger.error(f"Error running check for criterion {criterion.id}: {command_result['error']}")
                    results.append({
                        "criterion_id": criterion.id,
                        "status": "Error",
                        "details": f"Error running check: {command_result['error']}",
                        "remediation": criterion.remediation
                    })
                    continue
                
                # Get command output
                output = command_result["output"]
                if command_result["error"]:
                    output += f"\nErrors: {command_result['error']}"
                
                # Handle empty output
                if not output.strip():
                    output = "Command returned no output"
                
                # Determine status (Pass/Fail)
                expected = criterion.expected_output
                status = self.determine_status(criterion.id, output, expected)
                
                # Log the result
                logger.info(f"Criterion {criterion.id} check completed with status: {status}")
                
                # Add to results
                results.append({
                    "criterion_id": criterion.id,
                    "status": status,
                    "details": output,
                    "remediation": criterion.remediation if status == "Fail" else ""
                })
                
            except Exception as e:
                # Handle any exceptions during check
                logger.error(f"Exception during check for criterion {criterion.id}: {str(e)}")
                results.append({
                    "criterion_id": criterion.id,
                    "status": "Error",
                    "details": f"Exception during check: {str(e)}",
                    "remediation": criterion.remediation
                })
        
        logger.info(f"Scan completed with {len(results)} checks")
        return results
    
    def close(self):
        """Close the WinRM session"""
        # WinRM doesn't require explicit closing like SSH
        self.session = None
        logger.info("WinRM session closed")
    def close(self):
        """Close the WinRM session"""
        # WinRM не требует явного закрытия сессии, как SSH
        self.session = None
        logger.info("WinRM session closed")
